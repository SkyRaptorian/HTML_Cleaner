"""
A tool to clean up autogenerated html files into xhtml files for the creation of an epub using Beautiful Soup.

This script manages the logic of loading files.
"""

# IMPORTS ##############################################################################################################
import argparse  # Command line arguments

from bs4 import BeautifulSoup

# Custom classes
import htmlManager
from book import Format

import os.path

# CMD LINE ARGS ########################################################################################################

# CREATE CMD PARSER ----------------------------------------------------------------------------------------------------
cmd_parser = argparse.ArgumentParser()

# MANAGE ARGUMENTS -----------------------------------------------------------------------------------------------------
cmd_parser.add_argument("format",
                        help="The name of the format file to be used. It must be found in the format subfolder.")

# GET CMD LINE ARGS ----------------------------------------------------------------------------------------------------
cmd_args = cmd_parser.parse_args()  # GET PROVIDED ARGUMENTS

format_name = cmd_args.format  # NAME OF THE FORMAT TO BE USED
format_path = "format/{}.json".format(format_name)

# PROGRAM SET UP #######################################################################################################
# FORMAT SETUP ---------------------------------------------------------------------------------------------------------
if os.path.exists(format_path):  # Check if the book format file exists
    format_file = open(format_path, 'r')
    thisBook = Format(0, format_file)
    format_file.close()
else:  # NO FORMAT FOUND - EXIT
    print("Error: Format does not exist")
    exit()

# CREATE BOOK PART ARRAY
all_parts: dict = {}

# PROGRAM LOGIC ########################################################################################################
# MANAGE TYPE OF FORMAT ------------------------------------------------------------------------------------------------
match thisBook.type:
    case "LibreOffice":
        # BUILD CHAPTER PATH
        chapter_count = 1
        chapter_path = "{}/{}.html".format(thisBook.primary_path, thisBook.file_name)
        # LOOP THROUGH ALL CHAPTERS
        while os.path.exists(chapter_path.format(chapter_count)):
            file = open(chapter_path.format(chapter_count), "r")
            file_soup = BeautifulSoup(file, "html.parser")

            all_parts[chapter_count] = htmlManager.clean_libreOffice(file_soup, thisBook, chapter_count)

            file.close()

            chapter_count += 1
        print("CHAPTERS COMPLETE                                      ")  # WHITESPACE TO CLEAR LINE

        # LOOP THROUGH ALL ADDITIONAL PARTS
        for file_name in thisBook.additional_paths:
            additional_path = "{}/{}.html".format(thisBook.primary_path, file_name)
            if os.path.exists(additional_path):
                file = open(additional_path, "r")
                file_soup = BeautifulSoup(file, "html.parser")

                all_parts[file_name] = htmlManager.clean_libreOffice(file_soup, thisBook, file_name)

                file.close()
        print("ADDITIONAL COMPLETE                                    ")  # WHITESPACE TO CLEAR LINE
    case "ao3":
        # OPEN FILES
        file = open(thisBook.primary_path + ".html", "r")
        file_soup = BeautifulSoup(file, "html.parser")

        all_parts = htmlManager.clean_ao3(file_soup, thisBook)

        file.close()
    case "series":
        pass


file_name = "final/part-{}"
epub_roles = {"epub:type": "chapter", "role": "doc-chapter"}

# PRINT PART CHECK
for element in all_parts:
    part = all_parts[element]
    #print(part.part_soups)

    if "heading" in part.part_soups:
        title_text = thisBook.title + " | " + part.part_soups["heading"].string

        soup = htmlManager.create_base_xhtml(epub_roles, title_text)

        soup.section.append(part.part_soups["heading"])
    else:
        soup = htmlManager.create_base_xhtml(epub_roles, thisBook.title)
        # If no heading text provided then just book title

    if "byline" in part.part_soups:
        soup.section.append(part.part_soups["byline"])

    if "meta" in part.part_soups:
        soup.section.append(soup.new_tag("div", attrs={"class": "work-tags"}))
        soup.section.div.append(soup.new_tag("dl"))
        for tag_category in part.part_soups["meta"]:
            if not tag_category.string == "Collections:":
                soup.dl.append(tag_category)
                soup.dl.append(part.part_soups["meta"][tag_category])

    if "summary" in part.part_soups:
        soup.section.append(soup.new_tag("div", attrs={"class": "summary"}))
        htmlManager.create_summary("Summary", part.part_soups["summary"], soup.find("div", class_="summary"))

    if "start-notes" in part.part_soups:
        soup.section.append(soup.new_tag("div", attrs={"class": "notes"}))
        htmlManager.create_summary("Notes", part.part_soups["start-notes"], soup.find("div", class_="notes"))

    if "main-text" in part.part_soups:
        main_text = part.part_soups["main-text"]
        soup.section.append(main_text)

    if "end-notes" in part.part_soups:
        pass

    htmlManager.soup_to_file(soup, file_name.format(element))

# PRINT SHOW END OF PROJECT - WHITESPACE TO CLEAR PREVIOUS LETTERS
print("ALL COMPLETE                                   ")

